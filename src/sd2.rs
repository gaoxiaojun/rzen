// 特征序列合并方向
// 向下笔之间只有高高合并
// 向上笔之间只有低低合并

// 特征序列合并规则
// 前包含：前面的完全把后面的包含在内
// 后包含：后面的完全把前面的包含在内

// 第一特征序列的分型查找
// 顺着线段当前方向，合并特征序列，这里合并规则只考虑前包含，不考虑后包含
// 向上线段把向下笔作为第一特征序列，向下线段把向上笔作为第一特征序列
// 向上线段找顶分型，向下线段找底分型
// 顶分型只考虑特征序列1，2，3的高点，如果1 < 2 > 3则顶分型成立
// 底分型只考虑特征序列1，2，3的低点，如果1 > 2 < 3则底分型成立
// 找到分型后，把顶分型的高点、底分型的低点作为假设点

// 第二特征序列的分型查找
// 逆着线段当前方向，合并特征序列，这里合并规则前包含、后包含都要考虑
// 向上线段在假设点之后，把向上笔作为第二特征序列
// 向下线段在假设点之后，把向下笔作为第二特征序列
// 向上线段在假设点之后找底分型，向下线段在假设点之后找顶分型
// 顶分型的特征序列1，2，3，如果2的高点最高，2的低点也是最高，则顶分型成立
// 底分型的特征序列1，2，3，如果2的低点最低，2的高点也是最低，则底分型成立
// *第二特征序列只有在第一特征序列分型成立的情况下才有意义*

// 线段终结
// 第一步:寻找第一特征序列分型
// 第二步:判断是否是线段终结的第一种情况
// 2.1 是第一种情况（无gap），前线段终结,转终结处理（case1）
// 2.2 是第二种情况，开始检测第二特征序列
// 第三步:寻找第二特征分型
// 3.1 找到对应分型,则线段结束
// 3.1.1 第二特征序列的分型无gap，同时结束两个线段，转终结处理（case2）
// 3.1.2 第二特征序列的分型有gap，A段结束，转终结处理（case3）
// 3.2 未找到，第一特征序列出现新分型

// 线段终结后的处理
// 三种情况
// case1: 前线段终结，新线段开始,方向反转
// case2: 前两个线段终结，新线段开始，方向不变
// case3: 前线段终结，新线段开始，方向反转
// 三种情况都需要重新计算第一特征序列，转第一步

// 查找第一个线段
// 判断方式通过4个端点的滑动窗口来判断
// 向上线段，1-2-3-4，成立条件，1 < 2 > 3 < 4 同时 1 < 3 && 2 < 4，简化后 1 < 3 && 2 > 3 && 4 > 2
// 向下线段，1-2-3-4，成立条件，1 > 2 < 3 > 4 同时 1 > 3 && 2 > 4, 简化后 1 > 3 && 2 < 3 && 4 < 2
// 简单来说，就是形成N字

use crate::time::Time;
struct Line {
    x1: Time,
    y1: f64,
    x2: Time,
    y2: f64,
}
