// 总规则：
// 基于特征序列的线段划分标准方法主要步骤就是：
// 先根据线段方向，找出特征序列，然后对特征序列进行标准化，寻找标准特征序列的分型，然后判断分型第1,2元素间是否有缺口，分为第一种破坏和第二种破坏；
// 第一种破坏比较简单直接，当即可断定线段结束；
// 第二种破坏则需要寻找反向特征序列的分型来进行确认，如果没有出现反向特征序列分型就新高新低，则仍为原线段的延续。
// 可以解决90%的线段划分问题

// 特征序列合并方向
// 笔只有两个方向，向上或者向下
// 向下笔之间高高合并 向上笔之间低低合并

// 特征序列包含合并规则
// 前包含：前面的完全把后面的包含在内
// 后包含：后面的完全把前面的包含在内
// 合并的目的是找分型；找分型的目的是确定段的起始点

// 特征序列分型成立条件
// 特征序列分型分为第一元素、第二元素(定义为分型起点)和第三元素
// 顶分型：第二元素高点在相邻三个元素的高点中最高，低点比第三元素的低点高
// 底分型：第二元素低点在相邻三个元素的低点中最低，高点比第三元素的高点低
// 线段的端点必定是分型的起点
// 三个元素的不同合并规则
// 第一元素:只用前包含规则,处理完所有的前包含;如果出现后包含,前者为第一元素,后者为第二元素
// 第二元素:只用前包含规则,处理完所有的前包含;如果出现后包含,前者为第一元素,后者为第二元素
// 第三元素:不处理包含规则(这里是有争议的处理方案,按照本方案,79课的图一和图二的结果是相同)
// 或者采用如下规则:
// +---------+--------------------------------------------+------------------------------------+
// |         |            第一特征序列                      |       第二特征序列                   |
// |---------|-----------+----------+---------------------|-----------+------------+-----------|
// |         |  第一元素  |  第二元素  |  第三元素            |  第一元素  |  第二元素    |  第三元素  |
// |---------|-----------|----------|---------------------|---------- |------------|-----------|
// |  有缺口  |  前包含    |   前包含  |   不处理             |  前包含    | 只处理前包含 | 只处理一次  |
// |---------|-----------|----------|---------------------|  后包含    | 后包含时起点 |           |
// |  无缺口  |  前包含    |   前包含  | 第二元素包含第一元素时  |           | 后移        |           |
// |         |           |          | 只处理一次,不包含不处理 |           |            |           |
// +---------+-----------+----------+---------------------+-----------+------------+-----------+

// 第一特征序列的分型查找
// 顺着线段当前方向，合并特征序列，这里合并规则只考虑前包含，不考虑后包含
// 向上线段把向下笔作为第一特征序列，向下线段把向上笔作为第一特征序列
// 向上线段找顶分型，向下线段找底分型
// 找到分型后，把顶分型的高点、底分型的低点作为假设点

// 第二特征序列的分型查找
// 逆着线段当前方向，合并特征序列，这里合并规则前包含、后包含都要考虑
// 向上线段在假设点之后，把向上笔作为第二特征序列
// 向下线段在假设点之后，把向下笔作为第二特征序列
// 向上线段在假设点之后找底分型，向下线段在假设点之后找顶分型
// 顶分型的特征序列1，2，3，如果2的高点最高，2的低点也是最高，则顶分型成立
// 底分型的特征序列1，2，3，如果2的低点最低，2的高点也是最低，则底分型成立
// *第二特征序列只有在第一特征序列分型成立且有缺口的情况下才有意义*

// 线段终结
// 第一步:寻找第一特征序列分型
// 第二步:判断是否是线段终结的第一种情况
// 2.1 是第一种情况（无gap），前线段终结,转终结处理（case1）
// 2.2 是第二种情况，开始检测第二特征序列
// 第三步:寻找第二特征分型
// 3.1 找到对应分型,则线段结束
// 3.1.1 第二特征序列的分型无gap，同时结束两个线段，转终结处理（case2）
// 3.1.2 第二特征序列的分型有gap，A段结束，转终结处理（case3）
// 3.2 未找到，第一特征序列出现新分型

// 线段终结后的处理
// 三种情况
// case1: 前线段终结，新线段开始,方向反转, 新线段起点是分型顶点(也是旧线段的终结点),终点是??
// case2: 前两个线段终结，新线段开始，方向不变
// case3: 前线段终结，新线段开始，方向反转
// 三种情况都需要重新计算第一特征序列，转第一步

// 查找第一个线段
// 判断方式通过4个端点的滑动窗口来判断
// 向上线段，1-2-3-4，成立条件，1 < 2 > 3 < 4 同时 1 < 3 && 2 < 4，简化后 1 < 3 && 2 > 3 && 4 > 2
// 向下线段，1-2-3-4，成立条件，1 > 2 < 3 > 4 同时 1 > 3 && 2 > 4, 简化后 1 > 3 && 2 < 3 && 4 < 2
// 简单来说，就是形成N字

// 重新思考后过程：
// 1. 把第一特征序列的分型和第二特种序列的分型都放入同一个队列
// 2. 考虑类型相同的分型进行合并
// 3. 第一特征序列分型一直在计算
// 4. 当产生新的第一特征序列分型，就要重新计算第二特征序列分型

// 细节
// 出现第二种情况，如果分型未找到，但是出现了新高新低，放弃第二分型的查找，认为线段延续
// 在没有出现新高新低之前，按线段方向不断合并第一特征序列（这里是为了79课的问题，是否妥当要思考)

// 反向特征序列分型第三笔直接破底前面分型的顶底的情况,看做一段延伸还是3段,都是有道理的,看自己选择哪个标准

// 特殊案例的汇总
// 首先复杂线段都是在中枢震荡中产生的,单边趋势中一般都很简单
// 其次不用太纠结很多特殊案例,本质上都是规则问题,用一种统一的规则就可,1分钟级别的线段有些许不同,不影响具体的操作
// 79课的图一图二,图一三段,图二两段, 个人观点,图二可以作为三段,否则规则就不统一了.
// 77课的80-83,个人观点,也是为了规则统一,80-81,81-82,82-83三段

use crate::time::Time;
struct Line {
    x1: Time,
    y1: f64,
    x2: Time,
    y2: f64,
}
